# 3D Pipeline — Cube tournant avec Handle Pattern

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implémenter une pipeline 3D complète avec shaders WGSL, caméra perspective, depth buffer, et une API Handle Pattern exposée à TypeScript — résultat : un cube coloré qui tourne en temps réel.

**Architecture:** Rust possède `Vec<Entity>` (transform + mesh type) et `Vec<EntityGpu>` (uniform buffer + bind group par entité). TypeScript obtient un `usize` handle via `create_cube()` et pilote via `set_position/rotation/scale/camera`. La matrice MVP est calculée par Rust avec `glam` et uploadée en GPU avant chaque draw call.

**Tech Stack:** Rust 2024 edition, wgpu 28, glam 0.29 (bytemuck feature), bytemuck 1, wasm-bindgen 0.2, wasm-pack --target web, TypeScript, Vite 7.

**Design doc :** `docs/plans/2026-02-20-3d-pipeline-design.md`

---

## Structure des fichiers

```
engine-core/src/
├── lib.rs          ← Engine struct (wasm_bindgen) + toute la logique GPU
├── mesh.rs         ← Vertex struct + cube geometry (24 vertices, 36 indices)
├── camera.rs       ← Camera struct + matrices view/projection
├── scene.rs        ← Entity struct + MeshType enum
└── shader.wgsl     ← Vertex + fragment shaders WGSL
game-app/src/
└── main.ts         ← Démo : cube tournant avec delta-time
```

---

## Task 1 : Dépendances — ajouter `glam` et `bytemuck`

**Files:**
- Modify: `engine-core/Cargo.toml`

### Step 1 : Ajouter les dépendances

Dans `engine-core/Cargo.toml`, ajouter après la ligne `console_error_panic_hook` :

```toml
glam     = { version = "0.29", features = ["bytemuck"] }
bytemuck = { version = "1",    features = ["derive"] }
```

Le `Cargo.toml` complet doit ressembler à :

```toml
[package]
name = "engine-core"
version = "0.1.0"
edition = "2024"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
wasm-bindgen         = "0.2"
wasm-bindgen-futures = "0.4"
js-sys               = "0.3"
console_error_panic_hook = "0.1"
glam     = { version = "0.29", features = ["bytemuck"] }
bytemuck = { version = "1",    features = ["derive"] }

web-sys = { version = "0.3", features = [
    "console",
    "HtmlCanvasElement",
] }

[dependencies.wgpu]
version = "28"
default-features = false
features = ["webgpu", "wgsl"]
```

### Step 2 : Vérifier la résolution

```bash
cd E:/Programmation/webgpu-engine/engine-core
cargo fetch
cargo check --target wasm32-unknown-unknown 2>&1 | grep -E "^error|Finished"
```

Attendu : `Finished` sans erreur. Des erreurs dans `lib.rs` sont normales à ce stade si on a encore l'ancien code.

---

## Task 2 : Créer `mesh.rs` — Vertex + géométrie cube

**Files:**
- Create: `engine-core/src/mesh.rs`

### Step 1 : Écrire `engine-core/src/mesh.rs`

```rust
use bytemuck::{Pod, Zeroable};
use std::mem;

/// Vertex avec position xyz et couleur rgb.
/// #[repr(C)] garantit que bytemuck peut l'interpréter comme bytes bruts.
#[repr(C)]
#[derive(Copy, Clone, Debug, Pod, Zeroable)]
pub struct Vertex {
    pub position: [f32; 3],
    pub color:    [f32; 3],
}

impl Vertex {
    /// Descriptor pour wgpu : comment lire ce type depuis le vertex buffer.
    pub fn desc() -> wgpu::VertexBufferLayout<'static> {
        wgpu::VertexBufferLayout {
            array_stride: mem::size_of::<Vertex>() as wgpu::BufferAddress,
            step_mode: wgpu::VertexStepMode::Vertex,
            attributes: &[
                // @location(0) position
                wgpu::VertexAttribute {
                    offset: 0,
                    shader_location: 0,
                    format: wgpu::VertexFormat::Float32x3,
                },
                // @location(1) color
                wgpu::VertexAttribute {
                    offset: mem::size_of::<[f32; 3]>() as wgpu::BufferAddress,
                    shader_location: 1,
                    format: wgpu::VertexFormat::Float32x3,
                },
            ],
        }
    }
}

// 24 vertices (4 par face × 6 faces) → chaque face a sa propre couleur.
// L'ordre des faces : front, back, left, right, bottom, top.
pub const CUBE_VERTICES: &[Vertex] = &[
    // Front (z = +0.5) — rouge
    Vertex { position: [-0.5, -0.5,  0.5], color: [0.9, 0.2, 0.2] },
    Vertex { position: [ 0.5, -0.5,  0.5], color: [0.9, 0.2, 0.2] },
    Vertex { position: [ 0.5,  0.5,  0.5], color: [0.9, 0.2, 0.2] },
    Vertex { position: [-0.5,  0.5,  0.5], color: [0.9, 0.2, 0.2] },
    // Back (z = -0.5) — vert
    Vertex { position: [ 0.5, -0.5, -0.5], color: [0.2, 0.8, 0.2] },
    Vertex { position: [-0.5, -0.5, -0.5], color: [0.2, 0.8, 0.2] },
    Vertex { position: [-0.5,  0.5, -0.5], color: [0.2, 0.8, 0.2] },
    Vertex { position: [ 0.5,  0.5, -0.5], color: [0.2, 0.8, 0.2] },
    // Left (x = -0.5) — bleu
    Vertex { position: [-0.5, -0.5, -0.5], color: [0.2, 0.4, 0.9] },
    Vertex { position: [-0.5, -0.5,  0.5], color: [0.2, 0.4, 0.9] },
    Vertex { position: [-0.5,  0.5,  0.5], color: [0.2, 0.4, 0.9] },
    Vertex { position: [-0.5,  0.5, -0.5], color: [0.2, 0.4, 0.9] },
    // Right (x = +0.5) — jaune
    Vertex { position: [ 0.5, -0.5,  0.5], color: [0.9, 0.9, 0.2] },
    Vertex { position: [ 0.5, -0.5, -0.5], color: [0.9, 0.9, 0.2] },
    Vertex { position: [ 0.5,  0.5, -0.5], color: [0.9, 0.9, 0.2] },
    Vertex { position: [ 0.5,  0.5,  0.5], color: [0.9, 0.9, 0.2] },
    // Bottom (y = -0.5) — orange
    Vertex { position: [-0.5, -0.5, -0.5], color: [0.9, 0.5, 0.1] },
    Vertex { position: [ 0.5, -0.5, -0.5], color: [0.9, 0.5, 0.1] },
    Vertex { position: [ 0.5, -0.5,  0.5], color: [0.9, 0.5, 0.1] },
    Vertex { position: [-0.5, -0.5,  0.5], color: [0.9, 0.5, 0.1] },
    // Top (y = +0.5) — violet
    Vertex { position: [-0.5,  0.5,  0.5], color: [0.6, 0.2, 0.9] },
    Vertex { position: [ 0.5,  0.5,  0.5], color: [0.6, 0.2, 0.9] },
    Vertex { position: [ 0.5,  0.5, -0.5], color: [0.6, 0.2, 0.9] },
    Vertex { position: [-0.5,  0.5, -0.5], color: [0.6, 0.2, 0.9] },
];

// 36 indices : 6 faces × 2 triangles × 3 sommets. Winding CCW.
pub const CUBE_INDICES: &[u16] = &[
     0,  1,  2,   0,  2,  3,  // Front
     4,  5,  6,   4,  6,  7,  // Back
     8,  9, 10,   8, 10, 11,  // Left
    12, 13, 14,  12, 14, 15,  // Right
    16, 17, 18,  16, 18, 19,  // Bottom
    20, 21, 22,  20, 22, 23,  // Top
];
```

### Step 2 : Vérifier que le fichier compile (pas encore importé → pas d'erreur)

```bash
cd E:/Programmation/webgpu-engine/engine-core
cargo check --target wasm32-unknown-unknown 2>&1 | grep -E "^error|Finished"
```

Attendu : `Finished` (mesh.rs n'est pas encore importé, donc pas de "dead code" possible).

---

## Task 3 : Créer `camera.rs`

**Files:**
- Create: `engine-core/src/camera.rs`

### Step 1 : Écrire `engine-core/src/camera.rs`

```rust
use glam::{Mat4, Vec3};

pub struct Camera {
    pub eye:   Vec3,
    pub target: Vec3,
    pub up:    Vec3,
    pub fov_y: f32, // degrés
}

impl Default for Camera {
    fn default() -> Self {
        Camera {
            eye:    Vec3::new(3.0, 2.0, 5.0),
            target: Vec3::ZERO,
            up:     Vec3::Y,
            fov_y:  45.0,
        }
    }
}

impl Camera {
    /// Matrice de vue (world → camera space).
    pub fn view_matrix(&self) -> Mat4 {
        Mat4::look_at_rh(self.eye, self.target, self.up)
    }

    /// Matrice de projection perspective (camera → clip space).
    /// aspect = largeur / hauteur du canvas.
    pub fn proj_matrix(&self, aspect: f32) -> Mat4 {
        Mat4::perspective_rh(
            self.fov_y.to_radians(),
            aspect,
            0.1,    // near plane
            1000.0, // far plane
        )
    }
}
```

### Step 2 : Vérifier la compilation

```bash
cargo check --target wasm32-unknown-unknown 2>&1 | grep -E "^error|Finished"
```

---

## Task 4 : Créer `scene.rs`

**Files:**
- Create: `engine-core/src/scene.rs`

### Step 1 : Écrire `engine-core/src/scene.rs`

```rust
use glam::Vec3;

/// Types de maillage supportés. Extensible (Sphere, Mesh(id), etc.)
pub enum MeshType {
    Cube,
}

/// Données pures d'une entité (pas de ressources GPU ici).
pub struct Entity {
    pub position: Vec3,
    pub rotation: Vec3, // angles Euler en degrés (X, Y, Z)
    pub scale:    Vec3,
    pub mesh:     MeshType,
}

impl Entity {
    pub fn new_cube() -> Self {
        Entity {
            position: Vec3::ZERO,
            rotation: Vec3::ZERO,
            scale:    Vec3::ONE,
            mesh:     MeshType::Cube,
        }
    }
}
```

### Step 2 : Vérifier la compilation

```bash
cargo check --target wasm32-unknown-unknown 2>&1 | grep -E "^error|Finished"
```

---

## Task 5 : Créer `shader.wgsl`

**Files:**
- Create: `engine-core/src/shader.wgsl`

### Step 1 : Écrire `engine-core/src/shader.wgsl`

```wgsl
// Uniform : matrice MVP (model * view * projection) passée par Rust pour chaque entité.
@group(0) @binding(0)
var<uniform> mvp: mat4x4<f32>;

struct VertexInput {
    @location(0) position: vec3<f32>,
    @location(1) color:    vec3<f32>,
}

struct VertexOutput {
    @builtin(position) clip_pos: vec4<f32>,
    @location(0)       color:    vec3<f32>,
}

@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
    var out: VertexOutput;
    out.clip_pos = mvp * vec4<f32>(in.position, 1.0);
    out.color    = in.color;
    return out;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    return vec4<f32>(in.color, 1.0);
}
```

**Note :** `include_str!("shader.wgsl")` dans lib.rs embarque ce fichier dans le binaire WASM à la compilation.

---

## Task 6 : Réécrire `lib.rs` — Engine struct + init GPU

**Files:**
- Modify: `engine-core/src/lib.rs`

**Objectif :** Réécrire lib.rs complet avec tous les modules, la struct Engine (ressources GPU + scène + caméra), et la fonction `init` qui crée toute la pipeline.

### Step 1 : Écrire le nouveau `engine-core/src/lib.rs`

```rust
#![cfg(target_arch = "wasm32")]

mod camera;
mod mesh;
mod scene;

use camera::Camera;
use mesh::{Vertex, CUBE_INDICES, CUBE_VERTICES};
use scene::Entity;

use bytemuck;
use glam::{EulerRot, Mat4, Vec3};
use wasm_bindgen::prelude::*;
use web_sys::HtmlCanvasElement;
use wgpu::util::DeviceExt;

// ─── Ressources GPU par entité ───────────────────────────────────────────────

/// Chaque entité possède son propre uniform buffer + bind group.
/// Cela permet de rendre N entités en un seul render pass avec des MVP distincts.
struct EntityGpu {
    uniform_buffer: wgpu::Buffer,
    bind_group:     wgpu::BindGroup,
}

// ─── Engine ──────────────────────────────────────────────────────────────────

#[wasm_bindgen]
pub struct Engine {
    // GPU core
    device:          wgpu::Device,
    queue:           wgpu::Queue,
    surface:         wgpu::Surface<'static>,
    config:          wgpu::SurfaceConfiguration,

    // Profondeur (requis pour l'occlusion correcte des faces 3D)
    depth_texture:   wgpu::Texture,
    depth_view:      wgpu::TextureView,

    // Pipeline de rendu (shader compilé + vertex layout + depth state)
    render_pipeline:    wgpu::RenderPipeline,
    bind_group_layout:  wgpu::BindGroupLayout, // conservé pour create_cube()

    // Géométrie partagée (cube hardcodé, identique pour toutes les entités)
    vertex_buffer:   wgpu::Buffer,
    index_buffer:    wgpu::Buffer,

    // Scène : données logiques + ressources GPU (indices parallèles)
    entities:    Vec<Entity>,
    entity_gpu:  Vec<EntityGpu>,

    // Caméra
    camera: Camera,
}

// ─── Helper : créer la depth texture ─────────────────────────────────────────

fn create_depth_texture(
    device: &wgpu::Device,
    config: &wgpu::SurfaceConfiguration,
) -> (wgpu::Texture, wgpu::TextureView) {
    let texture = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("depth_texture"),
        size: wgpu::Extent3d {
            width:                 config.width,
            height:                config.height,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count:    1,
        dimension:       wgpu::TextureDimension::D2,
        format:          wgpu::TextureFormat::Depth32Float,
        usage:           wgpu::TextureUsages::RENDER_ATTACHMENT,
        view_formats:    &[],
    });
    let view = texture.create_view(&wgpu::TextureViewDescriptor::default());
    (texture, view)
}

// ─── wasm_bindgen API ─────────────────────────────────────────────────────────

#[wasm_bindgen]
impl Engine {
    /// Initialise WebGPU, compile les shaders et crée toute la pipeline.
    /// Retourne une JS Promise via wasm-bindgen.
    pub async fn init(canvas: HtmlCanvasElement) -> Result<Engine, JsValue> {
        console_error_panic_hook::set_once();

        // 1. Instance (backend navigateur uniquement)
        let instance = wgpu::Instance::new(&wgpu::InstanceDescriptor {
            backends: wgpu::Backends::BROWSER_WEBGPU,
            ..Default::default()
        });

        // 2. Surface depuis le canvas
        let width  = canvas.width();
        let height = canvas.height();
        let surface = instance
            .create_surface(wgpu::SurfaceTarget::Canvas(canvas))
            .map_err(|e| JsValue::from_str(&e.to_string()))?;

        // 3. Adapter
        let adapter = instance
            .request_adapter(&wgpu::RequestAdapterOptions {
                power_preference:       wgpu::PowerPreference::default(),
                compatible_surface:     Some(&surface),
                force_fallback_adapter: false,
            })
            .await
            .map_err(|e| JsValue::from_str(&format!("{e:?}")))?;

        // 4. Device + Queue
        let (device, queue) = adapter
            .request_device(&wgpu::DeviceDescriptor::default())
            .await
            .map_err(|e| JsValue::from_str(&e.to_string()))?;

        // 5. Configuration de la surface
        let surface_caps = surface.get_capabilities(&adapter);
        let format = surface_caps
            .formats
            .first()
            .copied()
            .ok_or_else(|| JsValue::from_str("Aucun format de surface supporté"))?;

        let config = wgpu::SurfaceConfiguration {
            usage:                         wgpu::TextureUsages::RENDER_ATTACHMENT,
            format,
            width,
            height,
            present_mode:                  wgpu::PresentMode::Fifo,
            alpha_mode:                    wgpu::CompositeAlphaMode::Opaque,
            view_formats:                  vec![],
            desired_maximum_frame_latency: 2,
        };
        surface.configure(&device, &config);

        // 6. Depth texture
        let (depth_texture, depth_view) = create_depth_texture(&device, &config);

        // 7. Shader (embarqué à la compilation via include_str!)
        let shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label:  Some("shader"),
            source: wgpu::ShaderSource::Wgsl(include_str!("shader.wgsl").into()),
        });

        // 8. Bind group layout : un uniform buffer (MVP matrix) par entité
        let bind_group_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("bind_group_layout"),
            entries: &[wgpu::BindGroupLayoutEntry {
                binding:    0,
                visibility: wgpu::ShaderStages::VERTEX,
                ty: wgpu::BindingType::Buffer {
                    ty:                 wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size:   None,
                },
                count: None,
            }],
        });

        // 9. Pipeline layout + render pipeline
        let pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label:                Some("pipeline_layout"),
            bind_group_layouts:   &[&bind_group_layout],
            push_constant_ranges: &[],
        });

        let render_pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
            label:  Some("render_pipeline"),
            layout: Some(&pipeline_layout),
            vertex: wgpu::VertexState {
                module:               &shader,
                entry_point:          Some("vs_main"),
                buffers:              &[Vertex::desc()],
                compilation_options:  wgpu::PipelineCompilationOptions::default(),
            },
            fragment: Some(wgpu::FragmentState {
                module:              &shader,
                entry_point:         Some("fs_main"),
                targets: &[Some(wgpu::ColorTargetState {
                    format,
                    blend:      Some(wgpu::BlendState::REPLACE),
                    write_mask: wgpu::ColorWrites::ALL,
                })],
                compilation_options: wgpu::PipelineCompilationOptions::default(),
            }),
            primitive: wgpu::PrimitiveState {
                topology:           wgpu::PrimitiveTopology::TriangleList,
                strip_index_format: None,
                front_face:         wgpu::FrontFace::Ccw,
                cull_mode:          Some(wgpu::Face::Back),
                ..Default::default()
            },
            depth_stencil: Some(wgpu::DepthStencilState {
                format:               wgpu::TextureFormat::Depth32Float,
                depth_write_enabled:  true,
                depth_compare:        wgpu::CompareFunction::Less,
                stencil:              wgpu::StencilState::default(),
                bias:                 wgpu::DepthBiasState::default(),
            }),
            multisample: wgpu::MultisampleState::default(),
            multiview:   None,
            cache:       None,
        });

        // 10. Vertex + index buffers (géométrie cube partagée)
        let vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label:    Some("vertex_buffer"),
            contents: bytemuck::cast_slice(CUBE_VERTICES),
            usage:    wgpu::BufferUsages::VERTEX,
        });

        let index_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label:    Some("index_buffer"),
            contents: bytemuck::cast_slice(CUBE_INDICES),
            usage:    wgpu::BufferUsages::INDEX,
        });

        web_sys::console::log_1(&"[Engine] Pipeline 3D initialisée".into());

        Ok(Engine {
            device,
            queue,
            surface,
            config,
            depth_texture,
            depth_view,
            render_pipeline,
            bind_group_layout,
            vertex_buffer,
            index_buffer,
            entities:   Vec::new(),
            entity_gpu: Vec::new(),
            camera:     Camera::default(),
        })
    }
}
```

### Step 2 : Vérifier la compilation

```bash
cd E:/Programmation/webgpu-engine/engine-core
cargo check --target wasm32-unknown-unknown 2>&1 | grep -E "^error|Finished"
```

Attendu : **0 erreurs**. Des warnings `dead_code` sur `depth_texture` et les champs non encore lus sont normaux.

**Erreurs potentielles wgpu 28 :**
- `cache: None` introuvable → supprimer ce champ
- `compilation_options` introuvable → supprimer ce champ
- `entry_point` attend `&str` et non `Option<&str>` → remplacer `Some("vs_main")` par `"vs_main"`

---

## Task 7 : Ajouter les méthodes de scène et `render_frame` dans `lib.rs`

**Files:**
- Modify: `engine-core/src/lib.rs`

**Objectif :** Ajouter un second bloc `#[wasm_bindgen] impl Engine` avec toutes les méthodes de l'API TS + `render_frame`.

### Step 1 : Ajouter ce bloc à la fin de `lib.rs`

```rust
#[wasm_bindgen]
impl Engine {
    // ── Scène ────────────────────────────────────────────────────────────────

    /// Crée un cube dans la scène. Retourne son handle (index dans Vec<Entity>).
    pub fn create_cube(&mut self) -> usize {
        let id = self.entities.len();
        self.entities.push(Entity::new_cube());

        // Créer un uniform buffer dédié à cette entité
        let uniform_buffer = self.device.create_buffer(&wgpu::BufferDescriptor {
            label:              Some("entity_uniform"),
            size:               std::mem::size_of::<Mat4>() as u64,
            usage:              wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
            mapped_at_creation: false,
        });

        // Bind group pour associer ce buffer au shader
        let bind_group = self.device.create_bind_group(&wgpu::BindGroupDescriptor {
            label:   Some("entity_bind_group"),
            layout:  &self.bind_group_layout,
            entries: &[wgpu::BindGroupEntry {
                binding:  0,
                resource: uniform_buffer.as_entire_binding(),
            }],
        });

        self.entity_gpu.push(EntityGpu { uniform_buffer, bind_group });
        id
    }

    /// Modifie la position d'une entité (aucun effet si id invalide).
    pub fn set_position(&mut self, id: usize, x: f32, y: f32, z: f32) {
        if let Some(e) = self.entities.get_mut(id) {
            e.position = Vec3::new(x, y, z);
        }
    }

    /// Modifie la rotation d'une entité en degrés Euler (XYZ).
    pub fn set_rotation(&mut self, id: usize, x: f32, y: f32, z: f32) {
        if let Some(e) = self.entities.get_mut(id) {
            e.rotation = Vec3::new(x, y, z);
        }
    }

    /// Modifie l'échelle d'une entité.
    pub fn set_scale(&mut self, id: usize, x: f32, y: f32, z: f32) {
        if let Some(e) = self.entities.get_mut(id) {
            e.scale = Vec3::new(x, y, z);
        }
    }

    // ── Caméra ───────────────────────────────────────────────────────────────

    /// Positionne la caméra (eye = position, target = point visé).
    pub fn set_camera(&mut self, ex: f32, ey: f32, ez: f32, tx: f32, ty: f32, tz: f32) {
        self.camera.eye    = Vec3::new(ex, ey, ez);
        self.camera.target = Vec3::new(tx, ty, tz);
    }

    // ── Rendu ─────────────────────────────────────────────────────────────────

    /// Rendu d'un frame. delta_ms = temps écoulé depuis le frame précédent (ms).
    /// Appelé par TypeScript à chaque requestAnimationFrame.
    pub fn render_frame(&self, _delta_ms: f32) {
        let output = match self.surface.get_current_texture() {
            Ok(t) => t,
            Err(wgpu::SurfaceError::OutOfMemory) => {
                web_sys::console::error_1(&"[Engine] GPU hors mémoire".into());
                return;
            }
            Err(_) => return, // Lost/Outdated/Timeout — skip ce frame
        };

        let view = output.texture.create_view(&wgpu::TextureViewDescriptor::default());
        let aspect = self.config.width as f32 / self.config.height as f32;

        // Matrices partagées par toutes les entités de ce frame
        let view_mat = self.camera.view_matrix();
        let proj_mat = self.camera.proj_matrix(aspect);

        let mut encoder = self.device.create_command_encoder(
            &wgpu::CommandEncoderDescriptor { label: Some("render_encoder") }
        );

        // Calculer et uploader les MVP de toutes les entités avant d'ouvrir le render pass
        for (i, entity) in self.entities.iter().enumerate() {
            let model = Mat4::from_translation(entity.position)
                * Mat4::from_euler(
                    EulerRot::XYZ,
                    entity.rotation.x.to_radians(),
                    entity.rotation.y.to_radians(),
                    entity.rotation.z.to_radians(),
                )
                * Mat4::from_scale(entity.scale);

            let mvp = proj_mat * view_mat * model;
            self.queue.write_buffer(
                &self.entity_gpu[i].uniform_buffer,
                0,
                bytemuck::bytes_of(&mvp),
            );
        }

        // Render pass unique avec clear color + depth clear
        {
            let mut pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                label: Some("render_pass"),
                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                    view:           &view,
                    resolve_target: None,
                    depth_slice:    None,
                    ops: wgpu::Operations {
                        load:  wgpu::LoadOp::Clear(wgpu::Color {
                            r: 0.05, g: 0.05, b: 0.08, a: 1.0,
                        }),
                        store: wgpu::StoreOp::Store,
                    },
                })],
                depth_stencil_attachment: Some(wgpu::RenderPassDepthStencilAttachment {
                    view: &self.depth_view,
                    depth_ops: Some(wgpu::Operations {
                        load:  wgpu::LoadOp::Clear(1.0),
                        store: wgpu::StoreOp::Store,
                    }),
                    stencil_ops: None,
                }),
                timestamp_writes:   None,
                occlusion_query_set: None,
                multiview_mask:     None,
            });

            pass.set_pipeline(&self.render_pipeline);
            pass.set_vertex_buffer(0, self.vertex_buffer.slice(..));
            pass.set_index_buffer(self.index_buffer.slice(..), wgpu::IndexFormat::Uint16);

            // Un draw call par entité avec son propre bind group (MVP unique)
            for gpu in &self.entity_gpu {
                pass.set_bind_group(0, &gpu.bind_group, &[]);
                pass.draw_indexed(0..36, 0, 0..1);
            }
        }

        self.queue.submit(std::iter::once(encoder.finish()));
        output.present();
    }
}
```

### Step 2 : Vérifier la compilation

```bash
cd E:/Programmation/webgpu-engine/engine-core
cargo check --target wasm32-unknown-unknown 2>&1 | grep -E "^error|Finished"
```

Attendu : **0 erreurs**. Quelques warnings `dead_code` sur `depth_texture` (normal — stocké pour éviter que wgpu le drop) et `MeshType::Cube` (normal).

---

## Task 8 : Build WASM + commit Rust

**Files:**
- No code change — build only.

### Step 1 : Build complet

```bash
cd E:/Programmation/webgpu-engine/engine-core
wasm-pack build --target web 2>&1 | tail -5
```

Attendu : `Done in XX.XXs` + `Your wasm pkg is ready`.

Si erreur wgpu 28 API (champ inconnu) : ajuster comme indiqué dans Task 6 Step 2.

### Step 2 : Commit

```bash
cd E:/Programmation/webgpu-engine/engine-core
git add Cargo.toml Cargo.lock src/lib.rs src/mesh.rs src/camera.rs src/scene.rs src/shader.wgsl
git commit -m "feat(engine-core): pipeline 3D (cube, camera, handle pattern, depth buffer)"

cd E:/Programmation/webgpu-engine
git add engine-core
git commit -m "feat: update engine-core submodule (3D pipeline)"
```

---

## Task 9 : Mettre à jour `main.ts` + test visuel

**Files:**
- Modify: `game-app/src/main.ts`

### Step 1 : Réécrire `game-app/src/main.ts`

```typescript
import init, { Engine } from '../../engine-core/pkg/engine_core.js';

await init();

const canvas = document.getElementById('game-canvas') as HTMLCanvasElement | null;
if (!canvas) throw new Error('Canvas #game-canvas introuvable');

let engine: Engine;
try {
  engine = await Engine.init(canvas);
} catch (err) {
  const msg = err instanceof Error ? err.message : String(err);
  document.body.innerHTML =
    `<pre style="color:red;padding:20px">Erreur WebGPU:\n${msg}</pre>`;
  throw err;
}

// Créer un cube et positionner la caméra
const cubeId = engine.create_cube();
engine.set_camera(3, 2, 5,   0, 0, 0);

let angle    = 0;
let lastTime = performance.now();

function loop(): void {
  const now   = performance.now();
  const delta = now - lastTime;
  lastTime    = now;

  // Faire tourner le cube sur l'axe Y en fonction du delta-time
  angle += delta * 0.05; // ~18°/sec

  engine.set_rotation(cubeId, 15, angle, 0);
  engine.render_frame(delta);
  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
```

### Step 2 : Commit

```bash
cd E:/Programmation/webgpu-engine
git add game-app/src/main.ts
git commit -m "feat(game-app): rotating cube demo with delta-time"
```

### Step 3 : Test visuel

1. S'assurer que `npm run dev` tourne dans `game-app/`
2. Rafraîchir http://localhost:5173 dans Chrome/Edge
3. **Attendu :** Un cube 3D aux faces colorées (rouge, vert, bleu, jaune, orange, violet) qui tourne lentement sur son axe Y, sur fond sombre. Les faces proches occultent les faces lointaines (depth testing actif).
4. Vérifier la console DevTools : `[Engine] Pipeline 3D initialisée` sans erreur.

### Step 4 : Debugging si écran noir ou crash

**Cube non visible mais pas d'erreur** → caméra peut-être à l'intérieur du cube. Essayer `engine.set_camera(0, 0, 5, 0, 0, 0)` dans main.ts.

**Erreur WGSL à la compilation** → vérifier que `shader.wgsl` est bien dans `src/` au même niveau que `lib.rs`.

**Faces qui se chevauchent bizarrement** → depth buffer non attaché. Vérifier `depth_stencil_attachment` dans `render_frame`.

**Erreur `entry_point` field** → si wgpu 28 attend `&str` et non `Option<&str>`, remplacer `Some("vs_main")` par `"vs_main"`.

---

## Rappel : workflow Rust → Browser

```bash
# Terminal 1 (laisser tourner)
cd game-app && npm run dev

# Terminal 2 (après chaque modif Rust)
cd engine-core && wasm-pack build --target web
# Puis Ctrl+Shift+R dans le navigateur (hard refresh)
```
